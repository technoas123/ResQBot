# Simulate MLX90614 (1-pixel thermal) sessions as CSVs under data/raw/thermal
import os, csv, time, argparse, random
from pathlib import Path
import numpy as np

def ensure_dir(p): Path(p).mkdir(parents=True, exist_ok=True)

def rand_uniform(a,b): return random.random()*(b-a)+a

def simulate_series(label: str, dur: float, sr: float, seed: int=None):
    """
    Returns t, ambient_c, object_c arrays.
    Enhanced with realistic challenges for better ML training.
    """
    if seed is not None:
        np.random.seed(seed); random.seed(seed)

    n = int(dur * sr)
    t = np.arange(n, dtype=np.float64) / sr
    
    # More realistic ambient with weather effects
    base_amb = rand_uniform(15.0, 35.0)  # Wider range for different environments
    # Weather effects: sunny day, night cooling, etc.
    weather_effect = 5.0 * np.sin(2*np.pi * 0.002 * t + rand_uniform(0, 2*np.pi))
    amb_drift = 0.3 * np.sin(2*np.pi * rand_uniform(0.005, 0.02) * t + rand_uniform(0, 2*np.pi))
    amb_noise = np.random.normal(0, 0.1, n)  # Increased noise
    ambient = base_amb + weather_effect + amb_drift + amb_noise

    # Object delta with realistic human temperature variations
    delta = np.zeros(n, dtype=np.float64)
    
    if label.lower() in ["human", "hot"]:
        # REALISTIC HUMAN: 35-38Â°C with variations
        human_base = rand_uniform(4.0, 6.0)  # Above ambient
        # Human body temperature fluctuates
        human_variation = 0.8 * np.sin(2*np.pi * rand_uniform(0.05, 0.2) * t)
        # Movement causes changes in detected temperature
        movement_effect = 1.0 * np.sin(2*np.pi * rand_uniform(0.1, 0.5) * t)
        delta[:] = human_base + human_variation + movement_effect
        
    elif label.lower() in ["cool", "empty", "background"]:
        # Background objects: some slightly warm, some cool
        obj_type = random.choice(["cool", "warm_object", "mixed"])
        if obj_type == "cool":
            delta[:] = rand_uniform(-2.0, 1.0)  # Cooler than ambient
        elif obj_type == "warm_object":
            delta[:] = rand_uniform(1.0, 4.0)   # Warm but not human-level
        else:  # mixed
            delta[:] = rand_uniform(-1.0, 3.0)   # Overlapping with human range
        
    elif label.lower() == "animal":
        # Animals have similar but different heat signatures
        delta[:] = rand_uniform(3.0, 5.0)  # Slightly different range
        
    elif label.lower() == "machinery":
        # Machinery can be hot but with different patterns
        base = rand_uniform(2.0, 8.0)
        # Machinery often has cyclic heating patterns
        cycle = 2.0 * np.sin(2*np.pi * rand_uniform(0.02, 0.1) * t)
        delta[:] = base + cycle

    # REALISTIC SENSOR EFFECTS
    # Increased sensor noise (real sensors are noisy)
    obj_noise = np.random.normal(0, 0.2, n)  # More noise
    
    # Sensor calibration drift (real sensors drift over time)
    calibration_drift = 0.01 * t * np.random.choice([-1, 1])
    
    # Occasional sensor spikes
    spikes_mask = np.random.rand(n) < 0.01  # More frequent spikes
    spikes = spikes_mask * np.random.normal(0, 1.0, n)  # Larger spikes

    # Calculate object temperature FIRST
    object_c = ambient + delta + obj_noise + calibration_drift + spikes
    ambient_c = ambient

    # NOW add dropouts (using the calculated object_c)
    dropouts = np.random.rand(n) < 0.005  # Sensor dropouts
    dropout_effect = dropouts * (-object_c * 0.8)  # Sudden reading drops
    object_c += dropout_effect

    # REALISTIC ENVIRONMENTAL CHALLENGES
    # Partial occlusions (people behind partial barriers)
    if random.random() < 0.3:  # 30% of sessions have occlusions
        occlusion_start = np.random.randint(0, n//2)
        occlusion_duration = np.random.randint(int(0.3*sr), int(2.0*sr))
        occlusion_mask = np.zeros(n)
        occlusion_mask[occlusion_start:occlusion_start+occlusion_duration] = 1
        # Reduce signal during occlusion
        object_c -= occlusion_mask * delta * rand_uniform(0.3, 0.8)

    # Distance effects (signal strength decreases with distance)
    distance_factor = rand_uniform(0.7, 1.0)  # Simulate different distances
    object_c = ambient + (object_c - ambient) * distance_factor

    # Clip to reasonable range
    object_c = np.clip(object_c, -10, 100)
    ambient_c = np.clip(ambient_c, -10, 60)

    return t, ambient_c.astype(np.float32), object_c.astype(np.float32)

def write_session(out_csv, t, amb, obj):
    ensure_dir(Path(out_csv).parent)
    with open(out_csv, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["t","ambient_c","object_c"])
        for i in range(len(t)):
            w.writerow([f"{t[i]:.3f}", f"{amb[i]:.4f}", f"{obj[i]:.4f}"])

def simulate_dataset(classes, train_n, val_n, dur, sr, out_root, seed=42):
    random.seed(seed); np.random.seed(seed)
    for split, count in [("train", train_n), ("val", val_n)]:
        for label in classes:
            out_dir = Path(out_root)/split/label
            ensure_dir(out_dir)
            for i in range(count):
                t, amb, obj = simulate_series(label, dur, sr, seed=None)
                ts = time.strftime("%Y%m%d_%H%M%S")
                out_csv = out_dir/f"session_{label}_{i:03d}_{ts}.csv"
                write_session(out_csv, t, amb, obj)
        print(f"Wrote {count} sessions per class for split={split} -> {out_root}")

if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("--classes", nargs="+", default=["human","background","animal","machinery"], 
                   help="space-separated class names: human, background, animal, machinery")
    ap.add_argument("--train_n", type=int, default=50)
    ap.add_argument("--val_n", type=int, default=20)
    ap.add_argument("--dur", type=float, default=10.0, help="seconds per session")
    ap.add_argument("--sr", type=float, default=10.0, help="samples per second")
    ap.add_argument("--out_root", default="data/raw/thermal")
    ap.add_argument("--seed", type=int, default=42)
    args = ap.parse_args()
    simulate_dataset(args.classes, args.train_n, args.val_n, args.dur, args.sr, args.out_root, args.seed)